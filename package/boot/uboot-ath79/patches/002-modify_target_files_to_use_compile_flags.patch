--- a/board/qca/mips32/qca955x/board955x.c
+++ b/board/qca/mips32/qca955x/board955x.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014, 2016-2017 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -23,7 +23,7 @@
 extern int ath_ddr_initial_config(uint32_t refresh);
 extern int ath_ddr_find_size(void);
 
-#ifdef COMPRESSED_UBOOT
+#if COMPRESSED_UBOOT
 #	define prmsg(...)
 #	define args		char *s
 #	define board_str(a)	do {			\
@@ -37,7 +37,7 @@ extern int ath_ddr_find_size(void);
 #	define prmsg	printf
 #	define args		void
 #	define board_str(a)				\
-	printf(a " - Scorpion 1.%d", ath_reg_rd		\
+	printf(a " - Scorpion 1.%d\n", ath_reg_rd		\
 			(RST_REVISION_ID_ADDRESS) & 0xf)
 #endif
 
@@ -126,9 +126,11 @@ ath_mem_config(void)
 	tap = (uint32_t *)0xbd007f10;
 	prmsg("Tap (low, high) = (0x%x, 0x%x)\n", tap[0], tap[1]);
 
-	tap = (uint32_t *)TAP_CONTROL_0_ADDRESS;
 	prmsg("Tap values = (0x%x, 0x%x, 0x%x, 0x%x)\n",
-		tap[0], tap[2], tap[2], tap[3]);
+		ath_reg_rd(TAP_CONTROL_0_ADDRESS),
+		ath_reg_rd(TAP_CONTROL_1_ADDRESS),
+		ath_reg_rd(TAP_CONTROL_2_ADDRESS),
+		ath_reg_rd(TAP_CONTROL_3_ADDRESS));
 
 	/* Take WMAC out of reset */
 	reg32 = ath_reg_rd(RST_RESET_ADDRESS);
@@ -150,7 +152,7 @@ phys_size_t initdram(int board_type)
 	return (ath_mem_config());
 }
 
-int	checkboard(args)
+int checkboard(args)
 {
 	board_str(CONFIG_BOARD_NAME);
 	return 0;
--- a/board/qca/mips32/qca955x/extra.c
+++ b/board/qca/mips32/qca955x/extra.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014, 2016-2017 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -30,57 +30,59 @@ ath_get_nand_cal_data(void)
 {
 	extern unsigned long long ath_nand_get_cal_offset(const char *ba);
 
-        ulong           off,size;
-        int             ret;
-        static u_char   nand_cal_data[256 * 1024];
-        nand_info_t *nand;
-
-         /*
-          * caldata partition is of 128k
-          *
-          */
-        nand = &nand_info[nand_curr_device];
-        size = nand->erasesize;
-
-        /*
-         * Get the Offset of Caldata partition
-         */
-        off = ath_nand_get_cal_offset(getenv("bootargs"));
-        if(off == ATH_CAL_OFF_INVAL) {
-                printf("Invalid CAL offset \n");
-                return 1;
-        }
-
-        /*
-         * Get the values from flash, and program into the MAC address
-         * registers
-         */
-        ret = nand_read(nand, (loff_t)off, &size, nand_cal_data);
-        printf(" %d bytes %s: %s\n", size,
-                        "read", ret ? "ERROR" : "OK");
-        if(ret != 0 ) {
-                return NULL;
-        }
+	ulong off,size;
+	int ret;
+	static u_char nand_cal_data[256 * 1024];
+	nand_info_t *nand;
+
+	/*
+	 * caldata partition is of 128k
+	 *
+	 */
+	nand = &nand_info[nand_curr_device];
+	size = nand->erasesize;
+
+	/*
+	 * Get the Offset of Caldata partition
+	 */
+
+	off = ath_nand_get_cal_offset(getenv("bootargs"));
+	if(off == ATH_CAL_OFF_INVAL) {
+		printf("Invalid CAL offset \n");
+		return 1;
+	}
+
+	/*
+	 * Get the values from flash, and program into the MAC address
+	 * registers
+	 */
+
+	ret = nand_read(nand, (loff_t)off, &size, nand_cal_data);
+	printf(" %d bytes %s: %s\n", size,
+		"read", ret ? "ERROR" : "OK");
+	if(ret != 0 ) {
+		return NULL;
+	}
 
-        return nand_cal_data;
+	return nand_cal_data;
 }
 #endif
 
 void ath_set_tuning_caps(void)
 {
 	typedef struct {
-		u_int8_t	pad[0x28],
-				params_for_tuning_caps[2],
-				featureEnable;
+		u_int8_t pad[0x28],
+		params_for_tuning_caps[2],
+		featureEnable;
 	} __attribute__((__packed__)) ar9300_eeprom_t;
 
 	ar9300_eeprom_t	*eep;
 	uint32_t	val;
 
 #ifdef CONFIG_ATH_NAND_BR
-        eep = (ar9300_eeprom_t *)ath_get_nand_cal_data();
+	eep = (ar9300_eeprom_t *)ath_get_nand_cal_data();
 #else
-        eep = (ar9300_eeprom_t *)WLANCAL;
+	eep = (ar9300_eeprom_t *)WLANCAL;
 #endif /* CONFIG_ATH_NAND_BR */
 
 	val =	XTAL_TCXODET_SET(0x0) |
--- a/board/qca/mips32/qca955x/flash.c
+++ b/board/qca/mips32/qca955x/flash.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014, 2016-2017 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
--- a/board/qca/mips32/qca955x/init-955x.c
+++ b/board/qca/mips32/qca955x/init-955x.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014, 2016-2017 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -170,8 +170,10 @@ ath_ddr_initial_config(uint32_t refresh)
 	uint32_t	*pll = (unsigned *)PLL_CONFIG_VAL_F;
 	uint32_t	bootstrap;
 
+#if !defined(CONFIG_DISPLAY_BOARDINFO)
 	prmsg("\nsri\n");
 	prmsg("Scorpion 1.%d\n", ath_reg_rd(RST_REVISION_ID_ADDRESS) & 0xf);
+#endif
 
 	bootstrap = ath_reg_rd(RST_BOOTSTRAP_ADDRESS);
 
@@ -225,12 +227,12 @@ ath_ddr_initial_config(uint32_t refresh)
 		prmsg("%s(%d): (", __func__, __LINE__);
 		if (RST_BOOTSTRAP_DDR_WIDTH_GET(bootstrap)) {
 			prmsg("32");
-                        ctl_config = CFG_DDR_CTL_CONFIG;
+			ctl_config = CFG_DDR_CTL_CONFIG;
 			cycle_val = CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_32;
 		} else {
 			prmsg("16");
 			cycle_val = CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_16;
-                        ctl_config = 0;
+			ctl_config = 0;
 		}
 
 		ctl_config |= CPU_DDR_SYNC_MODE;
@@ -349,7 +351,7 @@ ath_ddr_initial_config(uint32_t refresh)
 	ath_reg_wr_nf(DDR_REFRESH_ADDRESS, refresh);
 	udelay(100);
 
-        ath_reg_wr(TAP_CONTROL_0_ADDRESS, tap_val);
+	ath_reg_wr(TAP_CONTROL_0_ADDRESS, tap_val);
 	ath_reg_wr(TAP_CONTROL_1_ADDRESS, tap_val);
 
 	if (RST_BOOTSTRAP_DDR_WIDTH_GET(bootstrap)) {
@@ -365,9 +367,9 @@ ath_ddr_initial_config(uint32_t refresh)
 	}
 
 	/*
-         * Based on SGMII validation for stucks, packet errors were  observed and it was
-         * mostly due to noise pickup on SGMII lines. Switching regulator register is to
-         * be programmed with proper setting to avoid such stucks.
+	 * Based on SGMII validation for stucks, packet errors were  observed and it was
+	 * mostly due to noise pickup on SGMII lines. Switching regulator register is to
+	 * be programmed with proper setting to avoid such stucks.
 	 */
 	ath_reg_rmw_clear(PMU1_ADDRESS, (7<<1));
 	ath_reg_rmw_set(PMU1_ADDRESS, (1<<3));
@@ -469,8 +471,8 @@ void ath_sys_frequency()
 	}
 #endif
 done:
-        prmsg("cpu %u ddr %u ahb %u\n",
-		ath_cpu_freq / 1000000,
-		ath_ddr_freq / 1000000,
-		ath_ahb_freq / 1000000);
+		prmsg("cpu %u ddr %u ahb %u\n",
+			ath_cpu_freq / 1000000,
+			ath_ddr_freq / 1000000,
+			ath_ahb_freq / 1000000);
 }
--- a/board/qca/mips32/qca955x/qca-eth-955x.c
+++ b/board/qca/mips32/qca955x/qca-eth-955x.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014, 2016-2017 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -122,33 +122,33 @@ static int ath_gmac_recv(struct eth_devi
 	mac = (ath_gmac_mac_t *)dev->priv;
 
 	for (;;) {
-	     f = mac->fifo_rx[mac->next_rx];
-        if (ath_gmac_rx_owned_by_dma(f)) {
-	 /* check if the current Descriptor is_empty is 1,But the DMAed count is not-zero
-	    then move to desciprot where the packet is available */
-	   dmaed_pkt = (ath_gmac_reg_rd(mac, 0x194) >> 16);
-            if (!dmaed_pkt) {
-	        break ;
-              } else {
-                if (f->is_empty == 1) {
-                    while ( count < NO_OF_RX_FIFOS ) {
-                        if (++mac->next_rx >= NO_OF_RX_FIFOS) {
-                            mac->next_rx = 0;
-                        }
-                        f = mac->fifo_rx[mac->next_rx];
-                        /*
-                         * Break on valid data in the desc by checking
-                         *  empty bit.
-                         */
-                        if (!f->is_empty){
-                            count = 0;
-                            break;
-                        }
-                        count++;
-                    }
-               }
-            }
-	}
+		f = mac->fifo_rx[mac->next_rx];
+		if (ath_gmac_rx_owned_by_dma(f)) {
+		/* check if the current Descriptor is_empty is 1,But the DMAed count is not-zero
+		then move to desciprot where the packet is available */
+			dmaed_pkt = (ath_gmac_reg_rd(mac, 0x194) >> 16);
+			if (!dmaed_pkt) {
+				break ;
+			} else {
+				if (f->is_empty == 1) {
+					while ( count < NO_OF_RX_FIFOS ) {
+						if (++mac->next_rx >= NO_OF_RX_FIFOS) {
+							mac->next_rx = 0;
+						}
+						f = mac->fifo_rx[mac->next_rx];
+						/*
+						 * Break on valid data in the desc by checking
+						 *  empty bit.
+						 */
+						if (!f->is_empty){
+							count = 0;
+							break;
+						}
+						count++;
+					}
+				}
+			}
+		}
 
 		length = f->pkt_size;
 
@@ -177,7 +177,7 @@ void ath_gmac_mii_setup(ath_gmac_mac_t *
 	ath_reg_wr(SWITCH_CLOCK_SPARE_ADDRESS, 0x520);
 
 	if ((is_s17()  && mac->mac_unit == 0) || is_drqfn()) {
-        printf("Scorpion  ----> S17 PHY *\n");
+		printf("Scorpion  ----> S17 PHY *\n");
 		mgmt_cfg_val = 7;
 #ifndef ATH_RGMII_CAL
 		ath_reg_wr(ATH_ETH_CFG, ETH_CFG_ETH_RXDV_DELAY_SET(3) |
@@ -185,11 +185,11 @@ void ath_gmac_mii_setup(ath_gmac_mac_t *
 					ETH_CFG_RGMII_GE0_SET(1));
 
 		ath_reg_wr(ETH_XMII_ADDRESS, ETH_XMII_TX_INVERT_SET(1) |
-                                ETH_XMII_RX_DELAY_SET(2)  |
-                                ETH_XMII_TX_DELAY_SET(1)  |
-                                ETH_XMII_GIGE_SET(1));
+					ETH_XMII_RX_DELAY_SET(2) |
+					ETH_XMII_TX_DELAY_SET(1) |
+					ETH_XMII_GIGE_SET(1));
 #else
-        rgmii_cal_alg()
+		rgmii_cal_alg()
 #endif
 		udelay(1000);
 		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
@@ -198,29 +198,27 @@ void ath_gmac_mii_setup(ath_gmac_mac_t *
 	}
 
 	if (is_ar8033 () && mac->mac_unit == 1) {
-        printf("Scorpion ---->8033 PHY*\n");
-        mgmt_cfg_val = 7;
+		printf("Scorpion ---->8033 PHY*\n");
+		mgmt_cfg_val = 7;
 		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
 		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
 		return;
+	}
 
-
-        }
-    if (is_vir_phy()) {
-        printf("Scorpion ---->VIR PHY*\n");
-
-        ath_reg_wr(ATH_ETH_CFG, ETH_CFG_ETH_RXDV_DELAY_SET(3) |
+	if (is_vir_phy()) {
+		printf("Scorpion ---->VIR PHY*\n");
+		ath_reg_wr(ATH_ETH_CFG, ETH_CFG_ETH_RXDV_DELAY_SET(3) |
 					ETH_CFG_ETH_RXD_DELAY_SET(3)|
 					ETH_CFG_RGMII_GE0_SET(1));
 		ath_reg_wr(ETH_XMII_ADDRESS, ETH_XMII_TX_INVERT_SET(1) |
-                                ETH_XMII_RX_DELAY_SET(2)  |
-                                ETH_XMII_TX_DELAY_SET(1)  |
-                                ETH_XMII_GIGE_SET(1));
+				ETH_XMII_RX_DELAY_SET(2)  |
+				ETH_XMII_TX_DELAY_SET(1)  |
+				ETH_XMII_GIGE_SET(1));
 		udelay(1000);
 		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
 		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
 
-        return;
+		return;
 	}
 }
 
@@ -341,51 +339,53 @@ static void athr_gmac_sgmii_setup()
 
 #ifdef ATH_SGMII_FORCED_MODE
         ath_reg_wr(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_SPEED_SEL1_SET(1) |
-                                           MR_AN_CONTROL_PHY_RESET_SET(1)  |
-                                           MR_AN_CONTROL_DUPLEX_MODE_SET(1));
-        udelay(10);
-
-        ath_reg_wr(SGMII_CONFIG_ADDRESS, SGMII_CONFIG_MODE_CTRL_SET(2)   |
-                                          SGMII_CONFIG_FORCE_SPEED_SET(1) |
-                                          SGMII_CONFIG_SPEED_SET(2));
+					MR_AN_CONTROL_PHY_RESET_SET(1)  |
+					MR_AN_CONTROL_DUPLEX_MODE_SET(1));
+	udelay(10);
+
+	ath_reg_wr(SGMII_CONFIG_ADDRESS, SGMII_CONFIG_MODE_CTRL_SET(2)   |
+					SGMII_CONFIG_FORCE_SPEED_SET(1) |
+					SGMII_CONFIG_SPEED_SET(2));
 
-        printf ("SGMII in forced mode\n");
+	printf ("SGMII in forced mode\n");
 #else
 
 	ath_reg_wr(SGMII_CONFIG_ADDRESS, SGMII_CONFIG_MODE_CTRL_SET(2));
 
-	ath_reg_wr(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_AN_ENABLE_SET(1)
-                                      |MR_AN_CONTROL_PHY_RESET_SET(1));
+	ath_reg_wr(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_AN_ENABLE_SET(1) |
+					MR_AN_CONTROL_PHY_RESET_SET(1));
 
 	ath_reg_wr(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_AN_ENABLE_SET(1));
 #endif
-/*
- * SGMII reset sequence suggested by systems team.
- */
+
+	/*
+	 * SGMII reset sequence suggested by systems team.
+	 */
 
 	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_RX_CLK_N_RESET);
 
 	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1));
 
-	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1)
-                                    |SGMII_RESET_RX_125M_N_SET(1));
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1) |
+					SGMII_RESET_RX_125M_N_SET(1));
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1) |
+					SGMII_RESET_TX_125M_N_SET(1)	|
+					SGMII_RESET_RX_125M_N_SET(1));
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1) |
+					SGMII_RESET_TX_125M_N_SET(1)	|
+					SGMII_RESET_RX_125M_N_SET(1)	|
+					SGMII_RESET_RX_CLK_N_SET(1));
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1) |
+					SGMII_RESET_TX_125M_N_SET(1)	|
+					SGMII_RESET_RX_125M_N_SET(1)	|
+					SGMII_RESET_RX_CLK_N_SET(1)	|
+					SGMII_RESET_TX_CLK_N_SET(1));
 
-	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1)
-                                    |SGMII_RESET_TX_125M_N_SET(1)
-                                    |SGMII_RESET_RX_125M_N_SET(1));
-
-	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1)
-                                    |SGMII_RESET_TX_125M_N_SET(1)
-                                    |SGMII_RESET_RX_125M_N_SET(1)
-                                    |SGMII_RESET_RX_CLK_N_SET(1));
-
-	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1)
-                                    |SGMII_RESET_TX_125M_N_SET(1)
-                                    |SGMII_RESET_RX_125M_N_SET(1)
-                                    |SGMII_RESET_RX_CLK_N_SET(1)
-                                    |SGMII_RESET_TX_CLK_N_SET(1));
+	ath_reg_rmw_clear(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_PHY_RESET_SET(1));
 
-        ath_reg_rmw_clear(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_PHY_RESET_SET(1));
 	/*
 	 * WAR::Across resets SGMII link status goes to weird
 	 * state.
@@ -402,7 +402,7 @@ static void athr_gmac_sgmii_setup()
 		if (count++ == SGMII_LINK_WAR_MAX_TRY) {
 			printf ("Max resets limit reached exiting...\n");
 			break;
-	    	}
+		}
 		status = (ath_reg_rd(SGMII_DEBUG_ADDRESS) & 0xff);
 	}
 
@@ -495,9 +495,9 @@ static int ath_gmac_check_link(ath_gmac_
 			ath_gmac_set_mac_speed(mac, 1);
 			ath_gmac_reg_rmw_clear(mac, ATH_MAC_FIFO_CFG_5, (1 << 19));
 
-            if (is_ar8033() && mac->mac_unit == 1) {
-                ath_reg_wr(ETH_SGMII_ADDRESS, ETH_SGMII_PHASE0_COUNT_SET(1) |
-                                            ETH_SGMII_PHASE1_COUNT_SET(1));
+			if (is_ar8033() && mac->mac_unit == 1) {
+				ath_reg_wr(ETH_SGMII_ADDRESS, ETH_SGMII_PHASE0_COUNT_SET(1) |
+						ETH_SGMII_PHASE1_COUNT_SET(1));
 			}
 
 			break;
@@ -509,7 +509,7 @@ static int ath_gmac_check_link(ath_gmac_
 
 			if (is_ar8033() && mac->mac_unit == 1) {
 				ath_reg_wr(ETH_SGMII_ADDRESS, ETH_SGMII_PHASE0_COUNT_SET(19) |
-                                           ETH_SGMII_PHASE1_COUNT_SET(19));
+						ETH_SGMII_PHASE1_COUNT_SET(19));
 			}
 
 			break;
@@ -520,7 +520,6 @@ static int ath_gmac_check_link(ath_gmac_
 	}
 
 	if (mac->link && (duplex == mac->duplex) && (speed == mac->speed)) {
-		printf("Returnig without set up\n");
 		return 1;
 	}
 
@@ -545,14 +544,13 @@ static int ath_gmac_clean_rx(struct eth_
 	ath_gmac_mac_t *mac = (ath_gmac_mac_t*)dev->priv;
 
 	if (!ath_gmac_check_link(mac)) {
-		printf("Link not found\n");
 		return -1;
 	}
 
 	mac->next_rx = 0;
 
-    ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00);
-    ath_gmac_reg_wr(mac, ATH_MAC_CFG1, (ATH_MAC_CFG1_RX_EN | ATH_MAC_CFG1_TX_EN));
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00);
+	ath_gmac_reg_wr(mac, ATH_MAC_CFG1, (ATH_MAC_CFG1_RX_EN | ATH_MAC_CFG1_TX_EN));
 
 	for (i = 0; i < NO_OF_RX_FIFOS; i++) {
 		fr = mac->fifo_rx[i];
@@ -621,8 +619,8 @@ static int ath_gmac_setup_fifos(ath_gmac
 static void ath_gmac_halt(struct eth_device *dev)
 {
 	ath_gmac_mac_t *mac = (ath_gmac_mac_t *)dev->priv;
-        ath_gmac_reg_rmw_clear(mac, ATH_MAC_CFG1,(ATH_MAC_CFG1_RX_EN | ATH_MAC_CFG1_TX_EN));
-        ath_gmac_reg_wr(mac,ATH_MAC_FIFO_CFG_0,0x1f1f);
+	ath_gmac_reg_rmw_clear(mac, ATH_MAC_CFG1,(ATH_MAC_CFG1_RX_EN | ATH_MAC_CFG1_TX_EN));
+	ath_gmac_reg_wr(mac,ATH_MAC_FIFO_CFG_0,0x1f1f);
 	ath_gmac_reg_wr(mac,ATH_DMA_RX_CTRL, 0);
 	while (ath_gmac_reg_rd(mac, ATH_DMA_RX_CTRL));
 }
@@ -879,7 +877,7 @@ int ath_gmac_enet_initialize(bd_t * bis)
 		}
 #ifdef CONFIG_ATHRS_GMAC_SGMII
 	/*
-         * MAC unit 1 or drqfn package call sgmii setup.
+	 * MAC unit 1 or drqfn package call sgmii setup.
 	 */
 	if (i == 1 || is_drqfn())
 		athr_gmac_sgmii_setup();
@@ -887,8 +885,6 @@ int ath_gmac_enet_initialize(bd_t * bis)
 		ath_gmac_hw_start(ath_gmac_macs[i]);
 		ath_gmac_setup_fifos(ath_gmac_macs[i]);
 
-
-
 		udelay(100 * 1000);
 
 		{
@@ -910,7 +906,6 @@ int ath_gmac_enet_initialize(bd_t * bis)
 		printf("%s up\n",dev[i]->name);
 	}
 
-
 	return 1;
 }
 
@@ -923,9 +918,6 @@ ath_gmac_miiphy_read(char *devname, uint
 	volatile int           rddata;
 	uint16_t      ii = 0xFFFF;
 
-
-
-
 	/*
 	 * Check for previous transactions are complete. Added to avoid
 	 * race condition while running at higher frequencies.
@@ -956,8 +948,8 @@ ath_gmac_miiphy_read(char *devname, uint
 	val = ath_gmac_reg_rd(mac, ATH_MII_MGMT_STATUS);
 	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CMD, 0x0);
 
-    if (data != NULL)
-        *data = val;
+	if (data != NULL)
+		*data = val;
 	return val;
 }
 
@@ -965,9 +957,9 @@ int
 ath_gmac_miiphy_write(char *devname, uint32_t phy_addr, uint8_t reg, uint16_t data)
 {
 	ath_gmac_mac_t *mac   = ath_gmac_name2mac(devname);
-	uint16_t      addr  = (phy_addr << ATH_ADDR_SHIFT) | reg;
+	uint16_t addr  = (phy_addr << ATH_ADDR_SHIFT) | reg;
 	volatile int rddata;
-	uint16_t      ii = 0xFFFF;
+	uint16_t ii = 0xFFFF;
 
 
 	/*
@@ -998,7 +990,7 @@ ath_gmac_miiphy_write(char *devname, uin
 
 int cpu_eth_init(bd_t *bis)
 {
-        ath_gmac_enet_initialize(bis);
-        return 0;
+	ath_gmac_enet_initialize(bis);
+	return 0;
 }
 
--- a/include/955x.h
+++ b/include/955x.h
@@ -783,8 +783,7 @@
 
 #define DDR_RD_DATA_THIS_CYCLE_ADDRESS                               0x18000018
 
-/*#define TAP_CONTROL_0_ADDRESS                                        0x1800001c*/ /* Causes Exception in U-boot-2016*/
-#define TAP_CONTROL_0_ADDRESS                                        0xB800001c
+#define TAP_CONTROL_0_ADDRESS                                        0x1800001c
 #define TAP_CONTROL_1_ADDRESS                                        0x18000020
 #define TAP_CONTROL_2_ADDRESS                                        0x18000024
 #define TAP_CONTROL_3_ADDRESS                                        0x18000028
--- a/include/configs/nbg6616.h
+++ b/include/configs/nbg6616.h
@@ -143,9 +143,8 @@
 #define CONFIG_ATHEROS	1
 #define CONFIG_MACH_QCA955x 1
 /*#define CFG_INIT_STACK_IN_SRAM 1 -- OBSOLETE.*/
-#define CONFIG_AP135 1
-#define __CONFIG_BOARD_NAME ap135
-#define CONFIG_BOARD_NAME "ap135"
+#define __CONFIG_BOARD_NAME NBG6616
+#define CONFIG_BOARD_NAME "NBG6616"
 #define CFG_PLL_FREQ CFG_PLL_720_600_200
 #define ATH_SGMII_FORCED 1
 #define CONFIG_ATHRS17_PHY 1
@@ -157,6 +156,8 @@
 #define ATH_SGMII_FORCED_MODE 1
 #define ATH_RGMII_CAL 1
 #define CONFIG_LAST_STAGE_INIT
+#define CONFIG_DISPLAY_BOARDINFO 1
+#define CONFIG_CUSTOM_BOARDINFO 1
 
 #define CONFIG_SYS_SDRAM_BASE 0x80000000
 #define CONFIG_SYS_LOAD_ADDR 0x81000000
@@ -181,4 +182,3 @@
 #define CONFIG_MII 1
 #define CFG_CMD_MII 1
 #define CONFIG_COMMANDS 1
-
--- /dev/null
+++ b/configs/nbg6716_defconfig
@@ -0,0 +1,27 @@
+CONFIG_MIPS=y
+CONFIG_ARCH_ATH79=y
+CONFIG_TARGET_QCA955X=y
+CONFIG_SYS_CONFIG_NAME=nbg6716
+CONFIG_SYS_PROMPT="NBG6716X# "
+# CONFIG_CMD_BDI is not set
+# CONFIG_CMD_ELF is not set
+CONFIG_CMD_RUN=y
+CONFIG_CMD_SAVEENV=y
+CONFIG_CMD_PING=y
+# CONFIG_CMD_LOADB is not set
+# CONFIG_CMD_LOADS is not set
+CONFIG_CMD_FLASH=y
+# CONFIG_CMD_FPGA is not set
+# CONFIG_CMD_SETEXPR is not set
+CONFIG_USE_PRIVATE_LIBGCC=y
+CONFIG_SYS_MALLOC_F_LEN=0x200
+CONFIG_SYS_MALLOC_F=y
+CONFIG_OF_LIBFDT=y
+# CONFIG_OF_LIBFDT_OVERLAY
+# CONFIG_OF_CONTROL
+# CONFIG_DEFAULT_DEVICE_TREE="ap135"
+# CONFIG_DEFAULT_FDT_FILE="ap135.dtb"
+CONFIG_FIT=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_SYS_TEXT_BASE=0x9f000000
+CONFIG_NR_DRAM_BANKS=1
--- /dev/null
+++ b/include/configs/nbg6716.h
@@ -0,0 +1,184 @@
+#define CONFIG_MIPS32 1   /* MIPS32 CPU core  */
+#define CONFIG_BOOTDELAY 2   /* autoboot after 4 seconds */
+#define CONFIG_TIMESTAMP	/* Print image info with timestamp */
+
+/*
+ * Console I/O configuration
+ */
+#define CONFIG_BAUDRATE 115200
+#define CONFIG_SYS_BAUDRATE_TABLE  {115200}
+
+/* Console I/O Buffer Size */
+#define CONFIG_SYS_CBSIZE               512
+/* Print Buffer Size */
+#define CONFIG_SYS_PBSIZE (CONFIG_SYS_CBSIZE+sizeof(CONFIG_SYS_PROMPT)+16)
+
+#define CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2      "hush>"
+
+/*
+ * FLASH and environment organization
+ */
+#ifndef FLASH_SIZE
+#define FLASH_SIZE 16
+#endif
+
+#define CONFIG_SYS_MAX_FLASH_BANKS 1       /* max number of memory banks */
+#define CFG_MAX_FLASH_BANKS 1 /* max number of memory banks */
+
+#if (FLASH_SIZE == 16)
+#define CFG_MAX_FLASH_SECT      256     /* max number of sectors on one chip */
+#define ATH_MTDPARTS_MIB0       "8256k(mib0)"
+#elif (FLASH_SIZE == 8)
+#define CFG_MAX_FLASH_SECT      128     /* max number of sectors on one chip */
+#define ATH_MTDPARTS_MIB0       "64k(mib0)"
+#else
+#define CFG_MAX_FLASH_SECT      64      /* max number of sectors on one chip */
+#define ATH_MTDPARTS_MIB0       "64k(mib0)"
+#endif
+
+#define CFG_FLASH_SECTOR_SIZE   (64*1024)
+#if (FLASH_SIZE == 16)
+#define CFG_FLASH_SIZE          0x01000000      /* Total flash size */
+#elif (FLASH_SIZE == 8)
+#define CFG_FLASH_SIZE          0x00800000      /* max number of sectors on one chip */
+#else
+#define CFG_FLASH_SIZE          0x00400000      /* Total flash size */
+#endif
+
+#ifndef COMPRESSED_UBOOT
+#define ENABLE_DYNAMIC_CONF     1
+#endif
+
+#if (CFG_MAX_FLASH_SECT * CFG_FLASH_SECTOR_SIZE) != CFG_FLASH_SIZE
+#       error "Invalid flash configuration"
+#endif
+
+#define CFG_FLASH_WORD_SIZE     unsigned short
+
+#if defined(CONFIG_ATH_NAND_BR) && defined(COMPRESSED_UBOOT)
+#define CFG_FLASH_BASE                  0xa0100000
+#else
+/* NOR Flash start address */
+#define CFG_FLASH_BASE	0x9f000000
+#endif
+
+#ifdef COMPRESSED_UBOOT
+#define BOOTSTRAP_TEXT_BASE             CFG_FLASH_BASE
+#define BOOTSTRAP_CFG_MONITOR_BASE      BOOTSTRAP_TEXT_BASE
+#endif
+
+#define CONFIG_PCI_CONFIG_DATA_IN_OTP
+
+/*
+ * Defines to change flash size on reboot
+ */
+#ifdef ENABLE_DYNAMIC_CONF
+#define UBOOT_FLASH_SIZE                (256 * 1024)
+#define UBOOT_ENV_SEC_START             (CFG_FLASH_BASE + UBOOT_FLASH_SIZE)
+
+#define CFG_FLASH_MAGIC                 0xaabacada
+#define CFG_FLASH_MAGIC_F               (UBOOT_ENV_SEC_START + CFG_FLASH_SECTOR_SIZE - 0x20)
+#define CFG_FLASH_SECTOR_SIZE_F         *(volatile int *)(CFG_FLASH_MAGIC_F + 0x4)
+#define CFG_FLASH_SIZE_F                *(volatile int *)(CFG_FLASH_MAGIC_F + 0x8) /* Total flash size */
+#else
+#define CFG_FLASH_SIZE_F                CFG_FLASH_SIZE
+#define CFG_FLASH_SECTOR_SIZE_F         CFG_FLASH_SECTOR_SIZE
+#endif
+
+/*
+** Parameters defining the location of the calibration/initialization
+** information for the two Merlin devices.
+** NOTE: **This will change with different flash configurations**
+*/
+
+#define WLANCAL	0x9fff1000
+#define BOARDCAL	0x9fff0000
+#define ATHEROS_PRODUCT_ID	137
+#define CAL_SECTOR	(CFG_MAX_FLASH_SECT - 1)
+
+/* For Merlin, both PCI, PCI-E interfaces are valid */
+#define ATH_ART_PCICFG_OFFSET           12
+
+/*
+ * The following for ENV settings
+ */
+
+#define CONFIG_SYS_MAXARGS 16
+#define CONFIG_SYS_FLASH_BASE	0x9f000000
+#define CONFIG_SYS_MAX_FLASH_SECT	256
+
+#define CONFIG_ENV_IS_IN_FLASH  1
+#define CONFIG_ENV_SIZE CFG_FLASH_SECTOR_SIZE //CFG_ENV_SIZE
+#define CONFIG_ENV_ADDR 0x9f040000
+
+/* Timer Specific */
+#define CONFIG_SYS_MHZ  720
+/* Since the count is incremented every other tick, divide by 2 -- CFG_HZ*/
+#define CONFIG_SYS_MIPS_TIMER_FREQ      ((CONFIG_SYS_MHZ * 1000000)/2)
+
+#define CFG_DDR_REFRESH_VAL             0x4138
+
+/*
+ * The following #defines are needed to get flash environment right
+ */
+#define CONFIG_SYS_MONITOR_BASE 0x9f000000
+#define CONFIG_SYS_MONITOR_LEN  (192 << 10)
+#define CONFIG_SYS_MALLOC_LEN (512*1024)
+#define CONFIG_SYS_BOOTPARAMS_LEN (64*1024)
+/*
+ * Cache Configuration
+ */
+#define CONFIG_SYS_CACHELINE_SIZE 32
+#define CONFIG_SYS_ICACHE_SIZE 65536
+#define CONFIG_SYS_DCACHE_SIZE 32768
+
+#define CONFIG_PCI 1
+#define CONFIG_CMD_PCI
+#define CONFIG_PCI_SCAN_SHOW
+
+/*#define CONFIG_USB 1*/
+
+#define CONFIG_ATH_SOC 1
+#define CONFIG_ATHEROS	1
+#define CONFIG_MACH_QCA955x 1
+/*#define CFG_INIT_STACK_IN_SRAM 1 -- OBSOLETE.*/
+#define __CONFIG_BOARD_NAME NBG6716
+#define CONFIG_BOARD_NAME "NBG6716"
+#define CFG_PLL_FREQ CFG_PLL_720_600_200
+#define ATH_SGMII_FORCED 1
+#define CONFIG_ATHRS17_PHY 1
+#define CFG_ATH_GMAC_NMACS 2
+#define CFG_ATH_GE1_IS_CONNECTED 1
+#define CONFIG_ATHRS_GMAC_SGMII 1
+#define CONFIG_ATH_S17_WAN 1
+#define ATH_S17_MAC0_SGMII 1
+#define ATH_SGMII_FORCED_MODE 1
+#define ATH_RGMII_CAL 1
+#define CONFIG_LAST_STAGE_INIT
+#define CONFIG_DISPLAY_BOARDINFO 1
+#define CONFIG_CUSTOM_BOARDINFO 1
+
+#define CONFIG_SYS_SDRAM_BASE 0x80000000
+#define CONFIG_SYS_LOAD_ADDR 0x81000000
+
+/*
+ * Cache lock for stack
+ */
+#define CONFIG_SYS_INIT_SP_OFFSET 0x1000
+#define CFG_INIT_SRAM_SP_OFFSET 0xbd007000
+
+/*
+ * Image type
+ */
+#define CONFIG_LZMA 1
+#define CONFIG_IMAGE_FORMAT_LEGACY
+
+/*
+ * ethernet environment
+ */
+#define CONFIG_SYS_RX_ETH_BUFFER 8
+#define CONFIG_TFTP_BLOCKSIZE 512
+#define CONFIG_MII 1
+#define CFG_CMD_MII 1
+#define CONFIG_COMMANDS 1
