--- a/board/qca/mips32/qca955x/board955x.c
+++ b/board/qca/mips32/qca955x/board955x.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014, 2016-2017 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -23,7 +23,7 @@
 extern int ath_ddr_initial_config(uint32_t refresh);
 extern int ath_ddr_find_size(void);
 
-#ifdef COMPRESSED_UBOOT
+#if COMPRESSED_UBOOT
 #	define prmsg(...)
 #	define args		char *s
 #	define board_str(a)	do {			\
@@ -37,7 +37,7 @@ extern int ath_ddr_find_size(void);
 #	define prmsg	printf
 #	define args		void
 #	define board_str(a)				\
-	printf(a " - Scorpion 1.%d", ath_reg_rd		\
+	printf(a " - Scorpion 1.%d\n", ath_reg_rd		\
 			(RST_REVISION_ID_ADDRESS) & 0xf)
 #endif
 
@@ -97,6 +97,34 @@ ath_usb2_initial_config(void)
 
 void ath_gpio_config(void)
 {
+#if defined(CONFIG_BOARD_NBG6716) || defined(CONFIG_BOARD_NBG6616)
+	/* set GPIO 4,12,13,15,16,17,18,19 as output */
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, \
+		((1 << 4)|(1 << 12)|(1 << 13)|(1 << 15)|(1 << 16)|(1 << 17)|(1 << 18)|(1 << 19)));
+	ath_reg_rmw_clear(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK);
+	ath_reg_rmw_clear(GPIO_OUT_FUNCTION3_ADDRESS, \
+		(GPIO_OUT_FUNCTION3_ENABLE_GPIO_12_MASK| \
+		 GPIO_OUT_FUNCTION3_ENABLE_GPIO_13_MASK| \
+		 GPIO_OUT_FUNCTION3_ENABLE_GPIO_15_MASK));
+	ath_reg_rmw_clear(GPIO_OUT_FUNCTION4_ADDRESS, \
+		(GPIO_OUT_FUNCTION4_ENABLE_GPIO_16_MASK| \
+		 GPIO_OUT_FUNCTION4_ENABLE_GPIO_17_MASK| \
+		 GPIO_OUT_FUNCTION4_ENABLE_GPIO_18_MASK| \
+		 GPIO_OUT_FUNCTION4_ENABLE_GPIO_19_MASK));
+  #if defined(CONFIG_BOARD_NBG6616)
+	ath_reg_wr_nf(GPIO_SET_ADDRESS, \
+		((1 << 4)|(1 << 12)|(1 << 14)|(1 << 15)|(1 << 16)|(1 << 17)|(1 << 18)|(1 << 19)));
+	/* disable JTAG */
+	ath_reg_rmw_set(GPIO_FUNCTION_ADDRESS, 2);
+	/* Set GPIO 0 as output */
+	ath_reg_rmw_clear(GPIO_OE_ADDRESS, 1);
+	/* turn off USB2 LED */
+	ath_reg_wr_nf(GPIO_SET_ADDRESS, 1);
+  #else
+	ath_reg_wr_nf(GPIO_SET_ADDRESS, \
+		((1 << 4)|(1 << 12)|(1 << 13)|(1 << 15)|(1 << 16)|(1 << 17)|(1 << 18)|(1 << 19)));
+  #endif
+#else
 	/* disable the CLK_OBS on GPIO_4 and set GPIO4 as input */
 	ath_reg_rmw_clear(GPIO_OE_ADDRESS, (1 << 4));
 	ath_reg_rmw_clear(GPIO_OUT_FUNCTION1_ADDRESS, GPIO_OUT_FUNCTION1_ENABLE_GPIO_4_MASK);
@@ -107,6 +135,7 @@ void ath_gpio_config(void)
 	/* Turn off JUMPST_LED and 5Gz LED during bootup */
 	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 15));
 	ath_reg_rmw_set(GPIO_OE_ADDRESS, (1 << 12));
+#endif
 }
 
 int
@@ -126,9 +155,11 @@ ath_mem_config(void)
 	tap = (uint32_t *)0xbd007f10;
 	prmsg("Tap (low, high) = (0x%x, 0x%x)\n", tap[0], tap[1]);
 
-	tap = (uint32_t *)TAP_CONTROL_0_ADDRESS;
 	prmsg("Tap values = (0x%x, 0x%x, 0x%x, 0x%x)\n",
-		tap[0], tap[2], tap[2], tap[3]);
+		ath_reg_rd(TAP_CONTROL_0_ADDRESS),
+		ath_reg_rd(TAP_CONTROL_1_ADDRESS),
+		ath_reg_rd(TAP_CONTROL_2_ADDRESS),
+		ath_reg_rd(TAP_CONTROL_3_ADDRESS));
 
 	/* Take WMAC out of reset */
 	reg32 = ath_reg_rd(RST_RESET_ADDRESS);
@@ -150,7 +181,7 @@ phys_size_t initdram(int board_type)
 	return (ath_mem_config());
 }
 
-int	checkboard(args)
+int checkboard(args)
 {
 	board_str(CONFIG_BOARD_NAME);
 	return 0;
--- a/board/qca/mips32/qca955x/extra.c
+++ b/board/qca/mips32/qca955x/extra.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014, 2016-2017 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -30,57 +30,59 @@ ath_get_nand_cal_data(void)
 {
 	extern unsigned long long ath_nand_get_cal_offset(const char *ba);
 
-        ulong           off,size;
-        int             ret;
-        static u_char   nand_cal_data[256 * 1024];
-        nand_info_t *nand;
-
-         /*
-          * caldata partition is of 128k
-          *
-          */
-        nand = &nand_info[nand_curr_device];
-        size = nand->erasesize;
-
-        /*
-         * Get the Offset of Caldata partition
-         */
-        off = ath_nand_get_cal_offset(getenv("bootargs"));
-        if(off == ATH_CAL_OFF_INVAL) {
-                printf("Invalid CAL offset \n");
-                return 1;
-        }
-
-        /*
-         * Get the values from flash, and program into the MAC address
-         * registers
-         */
-        ret = nand_read(nand, (loff_t)off, &size, nand_cal_data);
-        printf(" %d bytes %s: %s\n", size,
-                        "read", ret ? "ERROR" : "OK");
-        if(ret != 0 ) {
-                return NULL;
-        }
+	ulong off,size;
+	int ret;
+	static u_char nand_cal_data[256 * 1024];
+	nand_info_t *nand;
+
+	/*
+	 * caldata partition is of 128k
+	 *
+	 */
+	nand = &nand_info[nand_curr_device];
+	size = nand->erasesize;
+
+	/*
+	 * Get the Offset of Caldata partition
+	 */
+
+	off = ath_nand_get_cal_offset(getenv("bootargs"));
+	if(off == ATH_CAL_OFF_INVAL) {
+		printf("Invalid CAL offset \n");
+		return 1;
+	}
+
+	/*
+	 * Get the values from flash, and program into the MAC address
+	 * registers
+	 */
+
+	ret = nand_read(nand, (loff_t)off, &size, nand_cal_data);
+	printf(" %d bytes %s: %s\n", size,
+		"read", ret ? "ERROR" : "OK");
+	if(ret != 0 ) {
+		return NULL;
+	}
 
-        return nand_cal_data;
+	return nand_cal_data;
 }
 #endif
 
 void ath_set_tuning_caps(void)
 {
 	typedef struct {
-		u_int8_t	pad[0x28],
-				params_for_tuning_caps[2],
-				featureEnable;
+		u_int8_t pad[0x28],
+		params_for_tuning_caps[2],
+		featureEnable;
 	} __attribute__((__packed__)) ar9300_eeprom_t;
 
 	ar9300_eeprom_t	*eep;
 	uint32_t	val;
 
 #ifdef CONFIG_ATH_NAND_BR
-        eep = (ar9300_eeprom_t *)ath_get_nand_cal_data();
+	eep = (ar9300_eeprom_t *)ath_get_nand_cal_data();
 #else
-        eep = (ar9300_eeprom_t *)WLANCAL;
+	eep = (ar9300_eeprom_t *)WLANCAL;
 #endif /* CONFIG_ATH_NAND_BR */
 
 	val =	XTAL_TCXODET_SET(0x0) |
--- a/board/qca/mips32/qca955x/flash.c
+++ b/board/qca/mips32/qca955x/flash.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014, 2016-2017 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
--- a/board/qca/mips32/qca955x/init-955x.c
+++ b/board/qca/mips32/qca955x/init-955x.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014, 2016-2017 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -170,8 +170,10 @@ ath_ddr_initial_config(uint32_t refresh)
 	uint32_t	*pll = (unsigned *)PLL_CONFIG_VAL_F;
 	uint32_t	bootstrap;
 
+#if !defined(CONFIG_DISPLAY_BOARDINFO)
 	prmsg("\nsri\n");
 	prmsg("Scorpion 1.%d\n", ath_reg_rd(RST_REVISION_ID_ADDRESS) & 0xf);
+#endif
 
 	bootstrap = ath_reg_rd(RST_BOOTSTRAP_ADDRESS);
 
@@ -225,12 +227,12 @@ ath_ddr_initial_config(uint32_t refresh)
 		prmsg("%s(%d): (", __func__, __LINE__);
 		if (RST_BOOTSTRAP_DDR_WIDTH_GET(bootstrap)) {
 			prmsg("32");
-                        ctl_config = CFG_DDR_CTL_CONFIG;
+			ctl_config = CFG_DDR_CTL_CONFIG;
 			cycle_val = CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_32;
 		} else {
 			prmsg("16");
 			cycle_val = CFG_DDR1_RD_DATA_THIS_CYCLE_VAL_16;
-                        ctl_config = 0;
+			ctl_config = 0;
 		}
 
 		ctl_config |= CPU_DDR_SYNC_MODE;
@@ -349,7 +351,7 @@ ath_ddr_initial_config(uint32_t refresh)
 	ath_reg_wr_nf(DDR_REFRESH_ADDRESS, refresh);
 	udelay(100);
 
-        ath_reg_wr(TAP_CONTROL_0_ADDRESS, tap_val);
+	ath_reg_wr(TAP_CONTROL_0_ADDRESS, tap_val);
 	ath_reg_wr(TAP_CONTROL_1_ADDRESS, tap_val);
 
 	if (RST_BOOTSTRAP_DDR_WIDTH_GET(bootstrap)) {
@@ -365,9 +367,9 @@ ath_ddr_initial_config(uint32_t refresh)
 	}
 
 	/*
-         * Based on SGMII validation for stucks, packet errors were  observed and it was
-         * mostly due to noise pickup on SGMII lines. Switching regulator register is to
-         * be programmed with proper setting to avoid such stucks.
+	 * Based on SGMII validation for stucks, packet errors were  observed and it was
+	 * mostly due to noise pickup on SGMII lines. Switching regulator register is to
+	 * be programmed with proper setting to avoid such stucks.
 	 */
 	ath_reg_rmw_clear(PMU1_ADDRESS, (7<<1));
 	ath_reg_rmw_set(PMU1_ADDRESS, (1<<3));
@@ -469,8 +471,8 @@ void ath_sys_frequency()
 	}
 #endif
 done:
-        prmsg("cpu %u ddr %u ahb %u\n",
-		ath_cpu_freq / 1000000,
-		ath_ddr_freq / 1000000,
-		ath_ahb_freq / 1000000);
+		prmsg("cpu %u ddr %u ahb %u\n",
+			ath_cpu_freq / 1000000,
+			ath_ddr_freq / 1000000,
+			ath_ahb_freq / 1000000);
 }
--- a/board/qca/mips32/qca955x/qca-eth-955x.c
+++ b/board/qca/mips32/qca955x/qca-eth-955x.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2016 The Linux Foundation. All rights reserved.
+ * Copyright (c) 2014, 2016-2017 The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -34,7 +34,11 @@
 #include <miiphy.h>
 #endif
 #define ath_gmac_unit2mac(_unit)     ath_gmac_macs[(_unit)]
+#if defined(CFG_ATH_SWAP_ETHACT)
+#define ath_gmac_name2mac(name)	   is_drqfn() ? ath_gmac_unit2mac(1):strcmp(name,"eth0") ? ath_gmac_unit2mac(0) : ath_gmac_unit2mac(1)
+#else
 #define ath_gmac_name2mac(name)	   is_drqfn() ? ath_gmac_unit2mac(1):strcmp(name,"eth0") ? ath_gmac_unit2mac(1) : ath_gmac_unit2mac(0)
+#endif
 
 int ath_gmac_miiphy_read(char *devname, uint32_t phaddr, uint8_t reg, uint16_t *data);
 int ath_gmac_miiphy_write(char *devname, uint32_t phaddr, uint8_t reg, uint16_t data);
@@ -122,33 +126,33 @@ static int ath_gmac_recv(struct eth_devi
 	mac = (ath_gmac_mac_t *)dev->priv;
 
 	for (;;) {
-	     f = mac->fifo_rx[mac->next_rx];
-        if (ath_gmac_rx_owned_by_dma(f)) {
-	 /* check if the current Descriptor is_empty is 1,But the DMAed count is not-zero
-	    then move to desciprot where the packet is available */
-	   dmaed_pkt = (ath_gmac_reg_rd(mac, 0x194) >> 16);
-            if (!dmaed_pkt) {
-	        break ;
-              } else {
-                if (f->is_empty == 1) {
-                    while ( count < NO_OF_RX_FIFOS ) {
-                        if (++mac->next_rx >= NO_OF_RX_FIFOS) {
-                            mac->next_rx = 0;
-                        }
-                        f = mac->fifo_rx[mac->next_rx];
-                        /*
-                         * Break on valid data in the desc by checking
-                         *  empty bit.
-                         */
-                        if (!f->is_empty){
-                            count = 0;
-                            break;
-                        }
-                        count++;
-                    }
-               }
-            }
-	}
+		f = mac->fifo_rx[mac->next_rx];
+		if (ath_gmac_rx_owned_by_dma(f)) {
+		/* check if the current Descriptor is_empty is 1,But the DMAed count is not-zero
+		then move to desciprot where the packet is available */
+			dmaed_pkt = (ath_gmac_reg_rd(mac, 0x194) >> 16);
+			if (!dmaed_pkt) {
+				break ;
+			} else {
+				if (f->is_empty == 1) {
+					while ( count < NO_OF_RX_FIFOS ) {
+						if (++mac->next_rx >= NO_OF_RX_FIFOS) {
+							mac->next_rx = 0;
+						}
+						f = mac->fifo_rx[mac->next_rx];
+						/*
+						 * Break on valid data in the desc by checking
+						 *  empty bit.
+						 */
+						if (!f->is_empty){
+							count = 0;
+							break;
+						}
+						count++;
+					}
+				}
+			}
+		}
 
 		length = f->pkt_size;
 
@@ -177,7 +181,7 @@ void ath_gmac_mii_setup(ath_gmac_mac_t *
 	ath_reg_wr(SWITCH_CLOCK_SPARE_ADDRESS, 0x520);
 
 	if ((is_s17()  && mac->mac_unit == 0) || is_drqfn()) {
-        printf("Scorpion  ----> S17 PHY *\n");
+		printf("Scorpion  ----> S17 PHY *\n");
 		mgmt_cfg_val = 7;
 #ifndef ATH_RGMII_CAL
 		ath_reg_wr(ATH_ETH_CFG, ETH_CFG_ETH_RXDV_DELAY_SET(3) |
@@ -185,11 +189,11 @@ void ath_gmac_mii_setup(ath_gmac_mac_t *
 					ETH_CFG_RGMII_GE0_SET(1));
 
 		ath_reg_wr(ETH_XMII_ADDRESS, ETH_XMII_TX_INVERT_SET(1) |
-                                ETH_XMII_RX_DELAY_SET(2)  |
-                                ETH_XMII_TX_DELAY_SET(1)  |
-                                ETH_XMII_GIGE_SET(1));
+					ETH_XMII_RX_DELAY_SET(2) |
+					ETH_XMII_TX_DELAY_SET(1) |
+					ETH_XMII_GIGE_SET(1));
 #else
-        rgmii_cal_alg()
+		rgmii_cal_alg()
 #endif
 		udelay(1000);
 		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
@@ -198,29 +202,27 @@ void ath_gmac_mii_setup(ath_gmac_mac_t *
 	}
 
 	if (is_ar8033 () && mac->mac_unit == 1) {
-        printf("Scorpion ---->8033 PHY*\n");
-        mgmt_cfg_val = 7;
+		printf("Scorpion ---->8033 PHY*\n");
+		mgmt_cfg_val = 7;
 		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
 		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
 		return;
+	}
 
-
-        }
-    if (is_vir_phy()) {
-        printf("Scorpion ---->VIR PHY*\n");
-
-        ath_reg_wr(ATH_ETH_CFG, ETH_CFG_ETH_RXDV_DELAY_SET(3) |
+	if (is_vir_phy()) {
+		printf("Scorpion ---->VIR PHY*\n");
+		ath_reg_wr(ATH_ETH_CFG, ETH_CFG_ETH_RXDV_DELAY_SET(3) |
 					ETH_CFG_ETH_RXD_DELAY_SET(3)|
 					ETH_CFG_RGMII_GE0_SET(1));
 		ath_reg_wr(ETH_XMII_ADDRESS, ETH_XMII_TX_INVERT_SET(1) |
-                                ETH_XMII_RX_DELAY_SET(2)  |
-                                ETH_XMII_TX_DELAY_SET(1)  |
-                                ETH_XMII_GIGE_SET(1));
+				ETH_XMII_RX_DELAY_SET(2)  |
+				ETH_XMII_TX_DELAY_SET(1)  |
+				ETH_XMII_GIGE_SET(1));
 		udelay(1000);
 		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val | (1 << 31));
 		ath_gmac_reg_wr(mac, ATH_MAC_MII_MGMT_CFG, mgmt_cfg_val);
 
-        return;
+		return;
 	}
 }
 
@@ -341,51 +343,53 @@ static void athr_gmac_sgmii_setup()
 
 #ifdef ATH_SGMII_FORCED_MODE
         ath_reg_wr(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_SPEED_SEL1_SET(1) |
-                                           MR_AN_CONTROL_PHY_RESET_SET(1)  |
-                                           MR_AN_CONTROL_DUPLEX_MODE_SET(1));
-        udelay(10);
-
-        ath_reg_wr(SGMII_CONFIG_ADDRESS, SGMII_CONFIG_MODE_CTRL_SET(2)   |
-                                          SGMII_CONFIG_FORCE_SPEED_SET(1) |
-                                          SGMII_CONFIG_SPEED_SET(2));
+					MR_AN_CONTROL_PHY_RESET_SET(1)  |
+					MR_AN_CONTROL_DUPLEX_MODE_SET(1));
+	udelay(10);
+
+	ath_reg_wr(SGMII_CONFIG_ADDRESS, SGMII_CONFIG_MODE_CTRL_SET(2)   |
+					SGMII_CONFIG_FORCE_SPEED_SET(1) |
+					SGMII_CONFIG_SPEED_SET(2));
 
-        printf ("SGMII in forced mode\n");
+	printf ("SGMII in forced mode\n");
 #else
 
 	ath_reg_wr(SGMII_CONFIG_ADDRESS, SGMII_CONFIG_MODE_CTRL_SET(2));
 
-	ath_reg_wr(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_AN_ENABLE_SET(1)
-                                      |MR_AN_CONTROL_PHY_RESET_SET(1));
+	ath_reg_wr(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_AN_ENABLE_SET(1) |
+					MR_AN_CONTROL_PHY_RESET_SET(1));
 
 	ath_reg_wr(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_AN_ENABLE_SET(1));
 #endif
-/*
- * SGMII reset sequence suggested by systems team.
- */
+
+	/*
+	 * SGMII reset sequence suggested by systems team.
+	 */
 
 	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_RX_CLK_N_RESET);
 
 	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1));
 
-	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1)
-                                    |SGMII_RESET_RX_125M_N_SET(1));
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1) |
+					SGMII_RESET_RX_125M_N_SET(1));
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1) |
+					SGMII_RESET_TX_125M_N_SET(1)	|
+					SGMII_RESET_RX_125M_N_SET(1));
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1) |
+					SGMII_RESET_TX_125M_N_SET(1)	|
+					SGMII_RESET_RX_125M_N_SET(1)	|
+					SGMII_RESET_RX_CLK_N_SET(1));
+
+	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1) |
+					SGMII_RESET_TX_125M_N_SET(1)	|
+					SGMII_RESET_RX_125M_N_SET(1)	|
+					SGMII_RESET_RX_CLK_N_SET(1)	|
+					SGMII_RESET_TX_CLK_N_SET(1));
 
-	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1)
-                                    |SGMII_RESET_TX_125M_N_SET(1)
-                                    |SGMII_RESET_RX_125M_N_SET(1));
-
-	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1)
-                                    |SGMII_RESET_TX_125M_N_SET(1)
-                                    |SGMII_RESET_RX_125M_N_SET(1)
-                                    |SGMII_RESET_RX_CLK_N_SET(1));
-
-	ath_reg_wr(SGMII_RESET_ADDRESS, SGMII_RESET_HW_RX_125M_N_SET(1)
-                                    |SGMII_RESET_TX_125M_N_SET(1)
-                                    |SGMII_RESET_RX_125M_N_SET(1)
-                                    |SGMII_RESET_RX_CLK_N_SET(1)
-                                    |SGMII_RESET_TX_CLK_N_SET(1));
+	ath_reg_rmw_clear(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_PHY_RESET_SET(1));
 
-        ath_reg_rmw_clear(MR_AN_CONTROL_ADDRESS, MR_AN_CONTROL_PHY_RESET_SET(1));
 	/*
 	 * WAR::Across resets SGMII link status goes to weird
 	 * state.
@@ -402,7 +406,7 @@ static void athr_gmac_sgmii_setup()
 		if (count++ == SGMII_LINK_WAR_MAX_TRY) {
 			printf ("Max resets limit reached exiting...\n");
 			break;
-	    	}
+		}
 		status = (ath_reg_rd(SGMII_DEBUG_ADDRESS) & 0xff);
 	}
 
@@ -495,9 +499,9 @@ static int ath_gmac_check_link(ath_gmac_
 			ath_gmac_set_mac_speed(mac, 1);
 			ath_gmac_reg_rmw_clear(mac, ATH_MAC_FIFO_CFG_5, (1 << 19));
 
-            if (is_ar8033() && mac->mac_unit == 1) {
-                ath_reg_wr(ETH_SGMII_ADDRESS, ETH_SGMII_PHASE0_COUNT_SET(1) |
-                                            ETH_SGMII_PHASE1_COUNT_SET(1));
+			if (is_ar8033() && mac->mac_unit == 1) {
+				ath_reg_wr(ETH_SGMII_ADDRESS, ETH_SGMII_PHASE0_COUNT_SET(1) |
+						ETH_SGMII_PHASE1_COUNT_SET(1));
 			}
 
 			break;
@@ -509,7 +513,7 @@ static int ath_gmac_check_link(ath_gmac_
 
 			if (is_ar8033() && mac->mac_unit == 1) {
 				ath_reg_wr(ETH_SGMII_ADDRESS, ETH_SGMII_PHASE0_COUNT_SET(19) |
-                                           ETH_SGMII_PHASE1_COUNT_SET(19));
+						ETH_SGMII_PHASE1_COUNT_SET(19));
 			}
 
 			break;
@@ -520,7 +524,6 @@ static int ath_gmac_check_link(ath_gmac_
 	}
 
 	if (mac->link && (duplex == mac->duplex) && (speed == mac->speed)) {
-		printf("Returnig without set up\n");
 		return 1;
 	}
 
@@ -545,14 +548,13 @@ static int ath_gmac_clean_rx(struct eth_
 	ath_gmac_mac_t *mac = (ath_gmac_mac_t*)dev->priv;
 
 	if (!ath_gmac_check_link(mac)) {
-		printf("Link not found\n");
 		return -1;
 	}
 
 	mac->next_rx = 0;
 
-    ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00);
-    ath_gmac_reg_wr(mac, ATH_MAC_CFG1, (ATH_MAC_CFG1_RX_EN | ATH_MAC_CFG1_TX_EN));
+	ath_gmac_reg_wr(mac, ATH_MAC_FIFO_CFG_0, 0x1f00);
+	ath_gmac_reg_wr(mac, ATH_MAC_CFG1, (ATH_MAC_CFG1_RX_EN | ATH_MAC_CFG1_TX_EN));
 
 	for (i = 0; i < NO_OF_RX_FIFOS; i++) {
 		fr = mac->fifo_rx[i];
@@ -621,8 +623,8 @@ static int ath_gmac_setup_fifos(ath_gmac
 static void ath_gmac_halt(struct eth_device *dev)
 {
 	ath_gmac_mac_t *mac = (ath_gmac_mac_t *)dev->priv;
-        ath_gmac_reg_rmw_clear(mac, ATH_MAC_CFG1,(ATH_MAC_CFG1_RX_EN | ATH_MAC_CFG1_TX_EN));
-        ath_gmac_reg_wr(mac,ATH_MAC_FIFO_CFG_0,0x1f1f);
+	ath_gmac_reg_rmw_clear(mac, ATH_MAC_CFG1,(ATH_MAC_CFG1_RX_EN | ATH_MAC_CFG1_TX_EN));
+	ath_gmac_reg_wr(mac,ATH_MAC_FIFO_CFG_0,0x1f1f);
 	ath_gmac_reg_wr(mac,ATH_DMA_RX_CTRL, 0);
 	while (ath_gmac_reg_rd(mac, ATH_DMA_RX_CTRL));
 }
@@ -793,8 +795,15 @@ int ath_gmac_enet_initialize(bd_t * bis)
 		memset(dev[i], 0, sizeof(struct eth_device));
 
 		sprintf(dev[i]->name, "eth%d", i);
+#if 0 /* for zyxel, we get MAC address from u-boot environment */
 		ath_gmac_get_ethaddr(dev[i]);
-
+#else
+	#ifdef CFG_ATH_SWAP_ETHACT
+		eth_getenv_enetaddr_by_index(CFG_ATH_GMAC_NMACS-1-i, dev[i]->enetaddr);
+	#else
+		eth_getenv_enetaddr_by_index(i, dev[i]->enetaddr);
+	#endif
+#endif
 		ath_gmac_macs[i]->mac_unit = i;
 		ath_gmac_macs[i]->mac_base = i ? ATH_GE1_BASE : ATH_GE0_BASE ;
 		ath_gmac_macs[i]->dev = dev[i];
@@ -845,10 +854,12 @@ int ath_gmac_enet_initialize(bd_t * bis)
 		if (ath_gmac_macs[i]->mac_unit == 0)
                         continue;
 #endif
+#ifndef CFG_ATH_SWAP_ETHACT
 		eth_register(dev[i]);
 #if(CONFIG_COMMANDS & CFG_CMD_MII)
 		miiphy_register(dev[i]->name, ath_gmac_miiphy_read, ath_gmac_miiphy_write);
 #endif
+#endif
 		ath_gmac_mii_setup(ath_gmac_macs[i]);
 
 		/* if using header for register configuration, we have to     */
@@ -879,7 +890,7 @@ int ath_gmac_enet_initialize(bd_t * bis)
 		}
 #ifdef CONFIG_ATHRS_GMAC_SGMII
 	/*
-         * MAC unit 1 or drqfn package call sgmii setup.
+	 * MAC unit 1 or drqfn package call sgmii setup.
 	 */
 	if (i == 1 || is_drqfn())
 		athr_gmac_sgmii_setup();
@@ -887,8 +898,6 @@ int ath_gmac_enet_initialize(bd_t * bis)
 		ath_gmac_hw_start(ath_gmac_macs[i]);
 		ath_gmac_setup_fifos(ath_gmac_macs[i]);
 
-
-
 		udelay(100 * 1000);
 
 		{
@@ -909,8 +918,16 @@ int ath_gmac_enet_initialize(bd_t * bis)
 	ath_gmac_phy_setup(ath_gmac_macs[i]->mac_unit);
 		printf("%s up\n",dev[i]->name);
 	}
-
-
+#if defined(CFG_ATH_SWAP_ETHACT)
+	strcpy(dev[1]->name, "eth0");
+	strcpy(dev[0]->name, "eth1");
+	eth_register(dev[1]);
+	eth_register(dev[0]);
+  #ifdef CONFIG_MII
+	miiphy_register(dev[1]->name, ath_gmac_miiphy_read, ath_gmac_miiphy_write);
+	miiphy_register(dev[0]->name, ath_gmac_miiphy_read, ath_gmac_miiphy_write);
+  #endif
+#endif
 	return 1;
 }
 
@@ -923,9 +940,6 @@ ath_gmac_miiphy_read(char *devname, uint
 	volatile int           rddata;
 	uint16_t      ii = 0xFFFF;
 
-
-
-
 	/*
 	 * Check for previous transactions are complete. Added to avoid
 	 * race condition while running at higher frequencies.
@@ -956,8 +970,8 @@ ath_gmac_miiphy_read(char *devname, uint
 	val = ath_gmac_reg_rd(mac, ATH_MII_MGMT_STATUS);
 	ath_gmac_reg_wr(mac, ATH_MII_MGMT_CMD, 0x0);
 
-    if (data != NULL)
-        *data = val;
+	if (data != NULL)
+		*data = val;
 	return val;
 }
 
@@ -965,9 +979,9 @@ int
 ath_gmac_miiphy_write(char *devname, uint32_t phy_addr, uint8_t reg, uint16_t data)
 {
 	ath_gmac_mac_t *mac   = ath_gmac_name2mac(devname);
-	uint16_t      addr  = (phy_addr << ATH_ADDR_SHIFT) | reg;
+	uint16_t addr  = (phy_addr << ATH_ADDR_SHIFT) | reg;
 	volatile int rddata;
-	uint16_t      ii = 0xFFFF;
+	uint16_t ii = 0xFFFF;
 
 
 	/*
@@ -998,7 +1012,7 @@ ath_gmac_miiphy_write(char *devname, uin
 
 int cpu_eth_init(bd_t *bis)
 {
-        ath_gmac_enet_initialize(bis);
-        return 0;
+	ath_gmac_enet_initialize(bis);
+	return 0;
 }
 
--- a/arch/mips/Kconfig
+++ b/arch/mips/Kconfig
@@ -44,6 +44,12 @@ config TARGET_DBAU1X00
 	select SUPPORTS_CPU_MIPS32_R2
 	select SYS_MIPS_CACHE_INIT_RAM_LOAD
 
+config TARGET_QCA955X
+	bool "Support QCA955X"
+	select SUPPORTS_BIG_ENDIAN
+	select SUPPORTS_CPU_MIPS32_R1
+	select SUPPORTS_CPU_MIPS32_R2
+
 config TARGET_PB1X00
 	bool "Support pb1x00"
 	select SUPPORTS_LITTLE_ENDIAN
@@ -59,6 +65,7 @@ source "board/imgtec/malta/Kconfig"
 source "board/micronas/vct/Kconfig"
 source "board/pb1x00/Kconfig"
 source "board/qemu-mips/Kconfig"
+source "board/qca/mips32/qca955x/Kconfig"
 
 if MIPS
 
